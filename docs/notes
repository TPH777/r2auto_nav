Introduction
-ROS is an OS that runs on top of Linux to ease communication and control of the robot.
-Kernel is a computer program that is the core of a computer’s operating system, with complete control over everything in the system, like process and memory and management.
-Shell is a program that converts user commands into something that the kernel can understand. It is usually accessed with a terminal.
●	Shell scripts are a file with a list of commands to be executed. It uses syntax like Python and C.
●	bashrc is a script file (with functions, aliases, etc) that is executed whenever the shell is started interactively.
○	Alias syntax: alias aliasname='commands'
○	export NAME=Value is used to define global environment variables (To configure the terminal’s environment)
■	$Name to access that value in terminal
●	source executes the content of the file in the current shell.

 
Aliases/Environment in PC bashrc
●	alias nb='nano ~/.bashrc'
●	alias sb='source ~/.bashrc'
●	alias gs='git status'
●	alias gp='git pull'
●	alias cw='cd ~/colcon_ws'
●	alias cs='cd ~/colcon_ws/src'
●	alias cb='cd ~/colcon_ws && colcon build --symlink-install && source ~/.bashrc'

●	export ROS_DOMAIN_ID=32 #TURTLEBOT3
●	alias sshrp='ssh ubuntu@`ssh aws cat rpi.txt`'
●	alias sshrp2='ssh ubuntu@`ssh aws cat rpi2.txt`'

●	export TURTLEBOT3_MODEL=burger
●	alias rteleop='ros2 run turtlebot3_teleop teleop_keyboard'
●	alias rslam='ros2 launch turtlebot3_cartographer cartographer.launch.py'

●	export GAZEBO_MODEL_PATH=~/colcon_ws/src/turtlebot3_simulations/turtlebot3_gazebo/models
●	alias grslam='ros2 launch turtlebot3_cartographer cartographer.launch.py use_sim_time:=TRUE’

Gazebo Launching: 
Default world: ros2 launch turtlebot3_gazebo turtlebot3_world.launch.py
Test world: ros2 launch turtlebot3_gazebo test_world.launch.py

 
TurtleBot Setup:
Robotis Turtlebot3 quick start guide (S1)
1.	Install ROS2, Gazebo, Cartographer, Navigation2
2.	Install Turtlebot3 Packages
●	Software in ROS is organised in packages. It might contain ROS nodes, a ROS-independent library, a dataset, configuration files, a third-party piece of software etc.
3.	Set the ROS environment domain id in bashrc.
●	ROS_DOMAIN_ID must be matched between Remote PC and TurtleBot3 for communication under the same network environment.
4.	Setup ROS2 Foxy in RPi
5.	Setup OpenCR: Install required packages on RPi to upload the OpenCR firmware.
●	OpenCR (Open-source Control Module) is developed for ROS embedded systems to provide completely open-source hardware and software.
6.	Bringup TurtleBot3 packages
●	ros2 launch will start up and configure a number of executables containing ROS2 nodes simultaneously (roscore-starting up ROS master)
●	ros2 topic list provides the available topics to subscribe to.
●	ros2 service list provides the available services to be called by a client. (On-demand)
 
ROS Sensors and Controls
-Event-driven programming; Consists of a main loop in ROS that listens for events, which calls a callback function in the subscriber.
-The ROS Master tracks publishers’ IP addresses and provides them to subscribers of those topics, to allow individual ROS nodes to locate one another. Afterwards, these nodes can communicate with each other peer-to-peer.
 


Publish and Subscribe
Practised in S1.5: Full Documentation
a.	Create a py_pubsub package in cs, and wget publisher and subscriber functions, ros2 pkg create --build-type ament_python packageName
b.	package.xml file contains meta information about the package, <exec_depend> should correspond to the node’s import statements, as it declares that the package needs rclpy and std_msgs classes.
○	Install packages using pip install packageName --user
c.	setup.py contains instructions for how to install the package; To allow ros2 run to run the node, entry point must be added to setup.py
d.	Build the package in cs: colcon build --packages-select py_pubsub
○	Rebuild the file after edits also.
e.	Source setup file: source install/setup.bash
f.	Talker command: ros2 run py_pubsub talker
g.	Listener command: ros2 run py_pubsub listener
